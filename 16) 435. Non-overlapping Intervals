435. Non-overlapping Intervals is the inverse problem of merging.
Letâ€™s go step by step in the same flow I used for Merge Intervals, with full dry run, recurrence intuition, and annotated code.

ğŸ“Œ Problem Statement (LeetCode 435)

You are given an array of intervals intervals[i] = [start_i, end_i].
You need to remove the minimum number of intervals so that the rest of the intervals are non-overlapping.

Example 1

Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: Remove [1,3], then the rest are non-overlapping.


Example 2

Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: Remove two [1,2], leave only one.

ğŸ”‘ Key Idea

Very similar to Activity Selection Problem / Maximum Meetings in One Room.

Instead of merging, we ask:
ğŸ‘‰ "How many intervals can I keep non-overlapping?"
ğŸ‘‰ Answer = Total intervals âˆ’ Max non-overlapping intervals kept.

Greedy strategy:

Sort intervals by end time.

Always pick the interval that ends earliest (so it leaves room for the next one).

Count how many we can keep.

ğŸ›  Step-by-Step Solution
Step 1: Sort by end time
sort(intervals.begin(), intervals.end(), [](auto &a, auto &b){
    return a[1] < b[1];  // sort by interval end
});

Step 2: Greedy selection

Keep track of the end of the last chosen interval (prevEnd).

If current intervalâ€™s start â‰¥ prevEnd â†’ non-overlapping, keep it.

Else â†’ overlapping, remove it (just donâ€™t count it).

Step 3: Return removals

removals = total_intervals - kept_non_overlapping_intervals.

ğŸ” Dry Run Example

Input:

[[1,2],[2,3],[3,4],[1,3]]


Sort by end:

[[1,2],[2,3],[1,3],[3,4]]


Start with prevEnd = -âˆ, count=0.

Interval [1,2]: 1 >= -âˆ â†’ keep â†’ count=1, prevEnd=2.

Interval [2,3]: 2 >= 2 â†’ keep â†’ count=2, prevEnd=3.

Interval [1,3]: 1 >= 3? âŒ â†’ overlap â†’ skip.

Interval [3,4]: 3 >= 3 â†’ keep â†’ count=3, prevEnd=4.

Kept = 3. Total = 4.
Removals = 4-3 = 1. âœ…

âœ… C++ Code with Inline Dry Run
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if(intervals.empty()) return 0;

        // Step 1: Sort by end time
        sort(intervals.begin(), intervals.end(), [](auto &a, auto &b){
            return a[1] < b[1];
        });
        // Dry run: [[1,2],[2,3],[1,3],[3,4]]

        int count = 0;        // how many non-overlapping intervals we can keep
        int prevEnd = INT_MIN; // end of last chosen interval

        for(auto &interval : intervals) {
            // Check if non-overlapping
            if(interval[0] >= prevEnd) {
                // Dry run: [1,2], -inf â†’ keep â†’ count=1, prevEnd=2
                //          [2,3], 2â‰¥2 â†’ keep â†’ count=2, prevEnd=3
                //          [1,3], 1â‰¥3? no â†’ skip
                //          [3,4], 3â‰¥3 â†’ keep â†’ count=3, prevEnd=4
                count++;
                prevEnd = interval[1]; 
            }
            // else â†’ overlapping, skip
        }

        // Total removals = total intervals - max kept
        return intervals.size() - count; // 4 - 3 = 1
    }
};

â± Complexity

Sorting: O(n log n)

Loop: O(n)

Total: O(n log n)

Space: O(1) (in-place sort).

ğŸ§  Pattern Recognition

Merge Intervals (56): "Merge overlapping â†’ return merged list."

Non-overlapping Intervals (435): "Count non-overlapping â†’ remove minimum to achieve that."

Interval Scheduling (Greedy): Always sort by end time when you want max non-overlapping.

ğŸ‘‰ Trick:

If problem says merge â†’ sort by start.

If problem says non-overlapping / max intervals â†’ sort by end.
