ğŸ”¹ Intuition

When you get a sequence of customers paying with 5, 10, 20:

The only way you fail is if at some point you canâ€™t give change.

So you must carefully manage your $5 bills, because theyâ€™re the foundation of change:

$10 needs one $5.

$20 needs $15 â†’ either ($10 + $5) or (3 * $5).

ğŸ‘‰ Key idea:

Always prefer to give back a $10 + $5 instead of 3 * $5.
Why? Because $5 bills are â€œsmaller coinsâ€ and are more versatile â€” almost every customerâ€™s change depends on them.

If you keep giving away too many $5s early, you may get stuck when later customers give $10.


âœ… So the intuition is:
â€œ$5 bills are precious. Save them whenever possible. Always use a $10 bill first when giving change for $20, because $5 is more flexible.â€


ğŸ”¹ Problem Statement (Simplified)

You are a lemonade seller. Each lemonade costs $5. Customers pay with $5, $10, or $20 bills (in that order).
You must give correct change immediately for each customer.

Return true if you can serve everyone correctly, otherwise false.

ğŸ”¹ Step 1: Logic

We maintain how many $5 bills and $10 bills we have (since $20 can never be used for giving change).

When a customer gives:

$5 â†’ no change needed â†’ just increase count of $5.

$10 â†’ need to give $5 back â†’ check if we have $5.

If yes â†’ give one $5, decrease count of $5, increase $10.

If not â†’ return false.

$20 â†’ need to give $15 back.

Prefer giving $10 + $5 (to save $5 for future).

If not possible â†’ try giving 3 * $5.

If neither works â†’ return false.

ğŸ”¹ Step 2: Example Dry Run

Input: bills = [5, 5, 5, 10, 20]

Customer 1: pays $5. (No change). â†’ fives=1, tens=0

Customer 2: pays $5. (No change). â†’ fives=2, tens=0

Customer 3: pays $5. (No change). â†’ fives=3, tens=0

Customer 4: pays $10. Need $5 back. â†’ give $5. â†’ fives=2, tens=1

Customer 5: pays $20. Need $15 back. Prefer $10+$5. â†’ give it. â†’ fives=1, tens=0

âœ… All served, return true.

ğŸ”¹ Step 3: Annotated Code with Inline Dry Run
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int fives = 0, tens = 0;  // track how many $5 and $10 bills we have
        
        for (int bill : bills) {
            
            if (bill == 5) {
                // Customer pays $5 â†’ no change needed
                fives++;
                // Dry run trace: just increase count of $5
                
            } else if (bill == 10) {
                // Customer pays $10 â†’ must give back $5
                if (fives > 0) {
                    fives--;   // give one $5
                    tens++;    // now we got a $10 bill
                } else {
                    return false;  // can't give change
                }
                // Dry run: example (after [5,5,10]): fives=1, tens=1
                
            } else { 
                // bill == 20 â†’ must give $15 back
                if (tens > 0 && fives > 0) {
                    // Best case: give one $10 and one $5
                    tens--;
                    fives--;
                } else if (fives >= 3) {
                    // Otherwise: give three $5 bills
                    fives -= 3;
                } else {
                    return false;  // can't give change
                }
                // Dry run: example (after [5,5,5,10,20]): fives=1, tens=0
            }
        }
        
        return true;  // successfully gave change to all customers
    }
};

ğŸ”¹ Step 4: Complexity

Time Complexity: O(n) â†’ iterate over all customers.

Space Complexity: O(1) â†’ only track two counters (fives, tens).

ğŸ”¹ Step 5: Pattern & Trick to Remember

This is a Greedy Problem:

Always try to use larger bills first when giving change ($10+$5 before 3*$5).

This preserves smaller bills ($5) for future customers.
