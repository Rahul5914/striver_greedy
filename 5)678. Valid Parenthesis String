ðŸ”¹ Problem Restatement

You are given a string s containing only:

'(' â†’ open parenthesis

')' â†’ close parenthesis

'*' â†’ wildcard that can act as '(', ')', or "" (empty)

Return true if the string can be a valid parenthesis string.

ðŸ”¹ Step 1: Logic & Intuition

The challenge = * can represent 3 choices â†’ brute force = exponential.
We need Greedy thinking.

ðŸ‘‰ Intuition:

Keep track of the possible range of open brackets as we scan left to right:

low = minimum open parentheses we must have (assuming * as ) when possible).

high = maximum open parentheses we can have (assuming * as ().

For each character:

'(' â†’ increase both low and high (+1 open).

')' â†’ decrease both low and high (close one open).

'*' â†’

If treated as ) â†’ decrease low.

If treated as ( â†’ increase high.

So effectively: low--, high++.

ðŸ”¹ Rule:

low canâ€™t go negative â†’ reset to 0.

If at any point high < 0 â†’ invalid (more ) than possible opens).

At the end â†’ valid if low == 0.

ðŸ”¹ Step 2: Example Dry Run

s = "(*))"

Start: low=0, high=0

( â†’ low=1, high=1

* â†’ low=0 (1-1), high=2 (1+1)

) â†’ low=0 (0-1 â†’ reset), high=1

) â†’ low=0 (0-1 â†’ reset), high=0

âœ… At the end low=0 â†’ valid.

ðŸ”¹ Step 3: Annotated Code with Inline Dry Run
class Solution {
public:
    bool checkValidString(string s) {
        int low = 0, high = 0;  // possible range of open parentheses
        
        for (char c : s) {
            if (c == '(') {
                // one more open bracket
                low++;  
                high++;
                
            } else if (c == ')') {
                // one close bracket
                low--;  
                high--;
                
            } else { // c == '*'
                // treat as ')' for low (reduce opens), '(' for high (increase opens)
                low--;
                high++;
            }
            
            // Dry run trace in-line:
            // Example "(*))"
            // Step 1 '(' -> low=1, high=1
            // Step 2 '*' -> low=0, high=2
            // Step 3 ')' -> low=0, high=1
            // Step 4 ')' -> low=0, high=0
            
            if (high < 0) return false;  // too many ')'
            if (low < 0) low = 0;        // low can't go negative
        }
        
        // valid if all opens can be closed
        return low == 0;
    }
};

ðŸ”¹ Step 4: Complexity

Time Complexity: O(n) (one scan).

Space Complexity: O(1) (just two counters).

ðŸ”¹ Step 5: Pattern & Trick

This is a range greedy problem â†’ keep track of min and max open parentheses.

* widens the possible range:

decreases min (it could be )),

increases max (it could be ().

At the end, if min = 0 â†’ âœ… valid.

ðŸ‘‰ This is a parenthesis + wildcard variation â†’ pattern often called Greedy Balance Range.
