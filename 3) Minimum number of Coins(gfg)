ðŸ”¹ Problem

Given an infinite supply of denominations {1, 2, 5, 10} and a target value n, find the minimum number of coins/notes required to make change.

ðŸ”¹ Step 1: Logic / Intuition

Since the denominations {1,2,5,10} are canonical, Greedy works.

Always pick the largest denomination â‰¤ remaining target.

Continue until target = 0.

Why greedy works here?

Because these denominations are designed so that smaller ones divide into larger ones cleanly (10=5*2, 5=2+2+1, etc.), so greedy always gives optimal.

ðŸ”¹ Step 2: Example Dry Run

Example 1: n = 39

Largest â‰¤ 39 â†’ 10 â†’ use 1 coin â†’ remaining = 29

Again 10 â†’ use 2nd coin â†’ remaining = 19

Again 10 â†’ use 3rd coin â†’ remaining = 9

Next â‰¤ 9 â†’ 5 â†’ use 4th coin â†’ remaining = 4

Next â‰¤ 4 â†’ 2 â†’ use 5th coin â†’ remaining = 2

Next â‰¤ 2 â†’ 2 â†’ use 6th coin â†’ remaining = 0
âœ… Total = 6 coins â†’ [10,10,10,5,2,2]

Example 2: n = 121

Take 10 twelve times â†’ remaining = 1 â†’ 12 coins used

Take 1 â†’ remaining = 0 â†’ 13 coins total
âœ… Answer = 13

ðŸ”¹ Step 3: Annotated Code with Inline Dry Run
class Solution {
public:
    int minCoins(int n) {
        // Indian currency denominations
        vector<int> coins = {10, 5, 2, 1};
        int count = 0; // count of coins used

        for (int coin : coins) {
            if (n >= coin) {
                int used = n / coin;   // how many coins of this type we can use
                count += used;         // add to total
                n -= used * coin;      // reduce remaining amount

                // Dry run trace:
                // Example n=39:
                // coin=10 â†’ use 3 â†’ count=3, n=9
                // coin=5  â†’ use 1 â†’ count=4, n=4
                // coin=2  â†’ use 2 â†’ count=6, n=0
                // coin=1  â†’ skip
            }
        }

        return count;
    }
};

ðŸ”¹ Step 4: Complexity

Time Complexity: O(k) where k = number of denominations (constant here, k=4).

Space Complexity: O(1) (just counters).

ðŸ”¹ Step 5: Pattern & Trick

For canonical coin systems (like Indian denominations), Greedy works.

For arbitrary coins, greedy can fail (e.g., coins {1,3,4}, target 6 â†’ greedy gives 4+1+1=3 but optimal is 3+3=2).

Trick to remember:

If problem explicitly says Indian coins â†’ use Greedy.

If problem gives custom denominations â†’ use DP (Unbounded Knapsack style).
