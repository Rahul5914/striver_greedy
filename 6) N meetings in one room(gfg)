üìå Problem Statement

You are given n meetings in the form of two arrays:

start[i] ‚Üí start time of the i-th meeting

end[i] ‚Üí end time of the i-th meeting

You have only one meeting room, and only one meeting can be held in the room at any given time.
Find the maximum number of meetings that can be accommodated.

‚ö†Ô∏è Note:

A meeting‚Äôs start time must be strictly greater than the end time of the previously chosen meeting.

That means, if one meeting ends at time t, another cannot start at exactly t.

Example 1

Input:

start = [1, 3, 0, 5, 8, 5]
end   = [2, 4, 6, 7, 9, 9]


Output:

4


Explanation:
The following 4 meetings can be scheduled:

(1,2), (3,4), (5,7), (8,9)


We solve it using an activity selection approach. Let‚Äôs go step by step.

üîë Intuition

Only one meeting can be held at a time.

To maximize the number of meetings, we should always pick the meeting that ends the earliest, because:

It frees up the room as soon as possible.

Leaves maximum room for future meetings.

So the greedy choice is ‚Üí Sort by end time and pick non-overlapping meetings.

üìù Steps

Pair each meeting as (end, start) so we can easily sort by end time.

Sort all meetings by their end times.

Keep track of the last meeting‚Äôs end time (lastEnd).

For each meeting:

If its start time is strictly greater than lastEnd ‚Üí take it.

Update lastEnd to current meeting‚Äôs end.

Count the number of meetings selected.

‚úÖ Example Dry Run

Input:
start = [1, 3, 0, 5, 8, 5]
end = [2, 4, 6, 7, 9, 9]

Pairs ‚Üí (end, start) =
(2,1), (4,3), (6,0), (7,5), (9,8), (9,5)

Sorted ‚Üí (2,1), (4,3), (6,0), (7,5), (9,8), (9,5)

Pick (2,1) ‚Üí lastEnd = 2

Next (4,3) ‚Üí 3 > 2 ‚úÖ pick ‚Üí lastEnd = 4

Next (6,0) ‚Üí 0 > 4 ‚ùå skip

Next (7,5) ‚Üí 5 > 4 ‚úÖ pick ‚Üí lastEnd = 7

Next (9,8) ‚Üí 8 > 7 ‚úÖ pick ‚Üí lastEnd = 9

Next (9,5) ‚Üí 5 > 9 ‚ùå skip

Total meetings = 4

üíª Code (C++)
class Solution {
  public:
    // Function to find the maximum number of meetings
    int maxMeetings(vector<int>& start, vector<int>& end) {
        int n = start.size();
        
        // Step 1: store meetings as {end, start}
        vector<pair<int,int>> meetings;
        for (int i = 0; i < n; i++) {
            meetings.push_back({end[i], start[i]});
        }
        
        // Step 2: sort by end time
        sort(meetings.begin(), meetings.end());
        
        // Step 3: apply greedy selection
        int count = 0;
        int lastEnd = -1;  // no meeting yet
        
        for (auto m : meetings) {
            int e = m.first;
            int s = m.second;
            
            if (s > lastEnd) {   // strictly greater
                count++;
                lastEnd = e;
            }
        }
        
        return count;
    }
};

‚è± Complexity

Sorting ‚Üí O(N log N)

Iteration ‚Üí O(N)

Extra space ‚Üí O(N) for storing pairs

So, Time = O(N log N), Space = O(N).

‚ö° Trick to Remember for Interviews:
This is the Activity Selection Problem.
Always sort by end time (not start!) and use greedy pick.
